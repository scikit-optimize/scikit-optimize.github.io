

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="Description" content="scikit-optimize: machine learning in Python">

  
  <title>skopt.optimizer.optimizer &mdash; scikit-optimize 0.7.3 documentation</title>
  
  <link rel="canonical" href="https://scikit-optimize.github.io/_modules/skopt/optimizer/optimizer.html" />

  
  <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  

  <link rel="stylesheet" href="../../../_static/css/vendor/bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
<script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
<script src="../../../_static/jquery.js"></script> 
</head>
<body>
<nav id="navbar" class="sk-docs-navbar navbar navbar-expand-md navbar-light bg-light py-0">
  <div class="container-fluid sk-docs-container px-0">
      <a class="navbar-brand py-0" href="../../../index.html">
        <img
          class="sk-brand-img"
          src="../../../_static/logo.png"
          alt="logo"/>
      </a>
    <button
      id="sk-navbar-toggler"
      class="navbar-toggler"
      type="button"
      data-toggle="collapse"
      data-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent"
      aria-expanded="false"
      aria-label="Toggle navigation"
    >
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="sk-navbar-collapse collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../../../install.html">Install</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../../../user_guide.html">User Guide</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../../../modules/classes.html">API</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../../../auto_examples/index.html">Examples</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../../../getting_started.html">Getting Started</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../../../development.html">Development</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="https://github.com/scikit-optimize/scikit-optimize">GitHub</a>
        </li>
        <li class="nav-item dropdown nav-more-item-dropdown">
          <a class="sk-nav-link nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">More</a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
              <a class="sk-nav-dropdown-item dropdown-item" href="../../../getting_started.html">Getting Started</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../../../development.html">Development</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="https://github.com/scikit-optimize/scikit-optimize">GitHub</a>
          </div>
        </li>
      </ul>
      <div id="searchbox" role="search">
          <div class="searchformwrapper">
          <form class="search" action="../../../search.html" method="get">
            <input class="sk-search-text-input" type="text" name="q" aria-labelledby="searchlabel" />
            <input class="sk-search-text-btn" type="submit" value="Go" />
          </form>
          </div>
      </div>
    </div>
  </div>
</nav>
<div class="d-flex" id="sk-doc-wrapper">
    <input type="checkbox" name="sk-toggle-checkbox" id="sk-toggle-checkbox">
    <label id="sk-sidemenu-toggle" class="sk-btn-toggle-toc btn sk-btn-primary" for="sk-toggle-checkbox">Toggle Menu</label>
    <div id="sk-sidebar-wrapper" class="border-right">
      <div class="sk-sidebar-toc-wrapper">
        <div class="sk-sidebar-toc-logo">
          <a href="../../../index.html">
            <img
              class="sk-brand-img"
              src="../../../_static/logo.png"
              alt="logo"/>
          </a>
        </div>
        <div class="btn-group w-100 mb-2" role="group" aria-label="rellinks">
            <a href="#" role="button" class="btn sk-btn-rellink py-1 disabled"">Prev</a><a href="../../index.html" role="button" class="btn sk-btn-rellink py-1" sk-rellink-tooltip="Module code">Up</a>
            <a href="#" role="button" class="btn sk-btn-rellink py-1 disabled"">Next</a>
        </div>
        <div class="alert alert-danger p-1 mb-2" role="alert">
          <p class="text-center mb-0">
          <strong>scikit-optimize 0.7.3</strong><br/>
          </p>
        </div>
          <div class="sk-sidebar-toc">
            
          </div>
      </div>
    </div>
    <div id="sk-page-content-wrapper">
      <div class="sk-page-content container-fluid body px-md-3" role="main">
        
  <h1>Source code for skopt.optimizer.optimizer</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fmin_l_bfgs_b</span>

<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">clone</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">is_regressor</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">sklearn.multioutput</span> <span class="kn">import</span> <span class="n">MultiOutputRegressor</span>
<span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">check_random_state</span>

<span class="kn">from</span> <span class="nn">..acquisition</span> <span class="kn">import</span> <span class="n">_gaussian_acquisition</span>
<span class="kn">from</span> <span class="nn">..acquisition</span> <span class="kn">import</span> <span class="n">gaussian_acquisition_1D</span>
<span class="kn">from</span> <span class="nn">..learning</span> <span class="kn">import</span> <span class="n">GaussianProcessRegressor</span>
<span class="kn">from</span> <span class="nn">..space</span> <span class="kn">import</span> <span class="n">Categorical</span>
<span class="kn">from</span> <span class="nn">..space</span> <span class="kn">import</span> <span class="n">Space</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">check_x_in_space</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">cook_estimator</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">create_result</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">has_gradients</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">is_listlike</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">is_2Dlistlike</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">normalize_dimensions</span>


<div class="viewcode-block" id="Optimizer"><a class="viewcode-back" href="../../../modules/generated/skopt.optimizer.Optimizer.html#skopt.Optimizer">[docs]</a><span class="k">class</span> <span class="nc">Optimizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Run bayesian optimisation loop.</span>

<span class="sd">    An `Optimizer` represents the steps of a bayesian optimisation loop. To</span>
<span class="sd">    use it you need to provide your own loop mechanism. The various</span>
<span class="sd">    optimisers provided by `skopt` use this class under the hood.</span>

<span class="sd">    Use this class directly if you want to control the iterations of your</span>
<span class="sd">    bayesian optimisation loop.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimensions : list, shape (n_dims,)</span>
<span class="sd">        List of search space dimensions.</span>
<span class="sd">        Each search dimension can be defined either as</span>

<span class="sd">        - a `(lower_bound, upper_bound)` tuple (for `Real` or `Integer`</span>
<span class="sd">          dimensions),</span>
<span class="sd">        - a `(lower_bound, upper_bound, &quot;prior&quot;)` tuple (for `Real`</span>
<span class="sd">          dimensions),</span>
<span class="sd">        - as a list of categories (for `Categorical` dimensions), or</span>
<span class="sd">        - an instance of a `Dimension` object (`Real`, `Integer` or</span>
<span class="sd">          `Categorical`).</span>

<span class="sd">    base_estimator : `&quot;GP&quot;`, `&quot;RF&quot;`, `&quot;ET&quot;`, `&quot;GBRT&quot;` or sklearn regressor,</span>
<span class="sd">    default=`&quot;GP&quot;`</span>
<span class="sd">        Should inherit from :obj:`sklearn.base.RegressorMixin`.</span>
<span class="sd">        In addition the `predict` method, should have an optional `return_std`</span>
<span class="sd">        argument, which returns `std(Y | x)`` along with `E[Y | x]`.</span>
<span class="sd">        If base_estimator is one of [&quot;GP&quot;, &quot;RF&quot;, &quot;ET&quot;, &quot;GBRT&quot;], a default</span>
<span class="sd">        surrogate model of the corresponding type is used corresponding to what</span>
<span class="sd">        is used in the minimize functions.</span>

<span class="sd">    n_random_starts : int, default=10</span>
<span class="sd">        .. deprecated::</span>
<span class="sd">            use `n_initial_points` instead.</span>

<span class="sd">    n_initial_points : int, default=10</span>
<span class="sd">        Number of evaluations of `func` with initialization points</span>
<span class="sd">        before approximating it with `base_estimator`. Points provided as</span>
<span class="sd">        `x0` count as initialization points. If len(x0) &lt; n_initial_points</span>
<span class="sd">        additional points are sampled at random.</span>

<span class="sd">    acq_func : string, default=`&quot;gp_hedge&quot;`</span>
<span class="sd">        Function to minimize over the posterior distribution. Can be either</span>

<span class="sd">        - `&quot;LCB&quot;` for lower confidence bound.</span>
<span class="sd">        - `&quot;EI&quot;` for negative expected improvement.</span>
<span class="sd">        - `&quot;PI&quot;` for negative probability of improvement.</span>
<span class="sd">        - `&quot;gp_hedge&quot;` Probabilistically choose one of the above three</span>
<span class="sd">          acquisition functions at every iteration.</span>
<span class="sd">            - The gains `g_i` are initialized to zero.</span>
<span class="sd">            - At every iteration,</span>
<span class="sd">                - Each acquisition function is optimised independently to</span>
<span class="sd">                  propose an candidate point `X_i`.</span>
<span class="sd">                - Out of all these candidate points, the next point `X_best` is</span>
<span class="sd">                  chosen by :math:`softmax(\eta g_i)`</span>
<span class="sd">                - After fitting the surrogate model with `(X_best, y_best)`,</span>
<span class="sd">                  the gains are updated such that :math:`g_i -= \mu(X_i)`</span>
<span class="sd">        - `&quot;EIps&quot; for negated expected improvement per second to take into</span>
<span class="sd">          account the function compute time. Then, the objective function is</span>
<span class="sd">          assumed to return two values, the first being the objective value and</span>
<span class="sd">          the second being the time taken in seconds.</span>
<span class="sd">        - `&quot;PIps&quot;` for negated probability of improvement per second. The</span>
<span class="sd">          return type of the objective function is assumed to be similar to</span>
<span class="sd">          that of `&quot;EIps</span>

<span class="sd">    acq_optimizer : string, `&quot;sampling&quot;` or `&quot;lbfgs&quot;`, default=`&quot;auto&quot;`</span>
<span class="sd">        Method to minimize the acquistion function. The fit model</span>
<span class="sd">        is updated with the optimal value obtained by optimizing `acq_func`</span>
<span class="sd">        with `acq_optimizer`.</span>

<span class="sd">        - If set to `&quot;auto&quot;`, then `acq_optimizer` is configured on the</span>
<span class="sd">          basis of the base_estimator and the space searched over.</span>
<span class="sd">          If the space is Categorical or if the estimator provided based on</span>
<span class="sd">          tree-models then this is set to be &quot;sampling&quot;`.</span>
<span class="sd">        - If set to `&quot;sampling&quot;`, then `acq_func` is optimized by computing</span>
<span class="sd">          `acq_func` at `n_points` randomly sampled points.</span>
<span class="sd">        - If set to `&quot;lbfgs&quot;`, then `acq_func` is optimized by</span>
<span class="sd">              - Sampling `n_restarts_optimizer` points randomly.</span>
<span class="sd">              - `&quot;lbfgs&quot;` is run for 20 iterations with these points as initial</span>
<span class="sd">                points to find local minima.</span>
<span class="sd">              - The optimal of these local minima is used to update the prior.</span>

<span class="sd">    random_state : int, RandomState instance, or None (default)</span>
<span class="sd">        Set random state to something other than None for reproducible</span>
<span class="sd">        results.</span>

<span class="sd">    acq_func_kwargs : dict</span>
<span class="sd">        Additional arguments to be passed to the acquistion function.</span>

<span class="sd">    acq_optimizer_kwargs : dict</span>
<span class="sd">        Additional arguments to be passed to the acquistion optimizer.</span>

<span class="sd">    model_queue_size : int or None, default=None</span>
<span class="sd">        Keeps list of models only as long as the argument given. In the</span>
<span class="sd">        case of None, the list has no capped length.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    Xi : list</span>
<span class="sd">        Points at which objective has been evaluated.</span>
<span class="sd">    yi : scalar</span>
<span class="sd">        Values of objective at corresponding points in `Xi`.</span>
<span class="sd">    models : list</span>
<span class="sd">        Regression models used to fit observations and compute acquisition</span>
<span class="sd">        function.</span>
<span class="sd">    space : Space</span>
<span class="sd">        An instance of :class:`skopt.space.Space`. Stores parameter search</span>
<span class="sd">        space used to sample points, bounds, and type of parameters.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Optimizer.__init__"><a class="viewcode-back" href="../../../modules/generated/skopt.optimizer.Optimizer.html#skopt.Optimizer.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">base_estimator</span><span class="o">=</span><span class="s2">&quot;gp&quot;</span><span class="p">,</span>
                 <span class="n">n_random_starts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_initial_points</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">acq_func</span><span class="o">=</span><span class="s2">&quot;gp_hedge&quot;</span><span class="p">,</span>
                 <span class="n">acq_optimizer</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
                 <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">model_queue_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">acq_func_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">acq_optimizer_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Configure acquisition function</span>

        <span class="c1"># Store and creat acquisition function set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span> <span class="o">=</span> <span class="n">acq_func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acq_func_kwargs</span> <span class="o">=</span> <span class="n">acq_func_kwargs</span>

        <span class="n">allowed_acq_funcs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gp_hedge&quot;</span><span class="p">,</span> <span class="s2">&quot;EI&quot;</span><span class="p">,</span> <span class="s2">&quot;LCB&quot;</span><span class="p">,</span> <span class="s2">&quot;PI&quot;</span><span class="p">,</span> <span class="s2">&quot;EIps&quot;</span><span class="p">,</span> <span class="s2">&quot;PIps&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_acq_funcs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expected acq_func to be in </span><span class="si">%s</span><span class="s2">, got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">allowed_acq_funcs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span><span class="p">))</span>

        <span class="c1"># treat hedging method separately</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span> <span class="o">==</span> <span class="s2">&quot;gp_hedge&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cand_acq_funcs_</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;EI&quot;</span><span class="p">,</span> <span class="s2">&quot;LCB&quot;</span><span class="p">,</span> <span class="s2">&quot;PI&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gains_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cand_acq_funcs_</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">acq_func_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">acq_func_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">acq_func_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;eta&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># Configure counters of points</span>

        <span class="c1"># Check `n_random_starts` deprecation first</span>
        <span class="k">if</span> <span class="n">n_random_starts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">((</span><span class="s2">&quot;n_random_starts will be removed in favour of &quot;</span>
                           <span class="s2">&quot;n_initial_points.&quot;</span><span class="p">),</span>
                          <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">n_initial_points</span> <span class="o">=</span> <span class="n">n_random_starts</span>

        <span class="k">if</span> <span class="n">n_initial_points</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Expected `n_initial_points` &gt;= 0, got </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n_initial_points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_initial_points</span> <span class="o">=</span> <span class="n">n_initial_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_initial_points_</span> <span class="o">=</span> <span class="n">n_initial_points</span>

        <span class="c1"># Configure estimator</span>

        <span class="c1"># build base_estimator if doesn&#39;t exist</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_estimator</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">base_estimator</span> <span class="o">=</span> <span class="n">cook_estimator</span><span class="p">(</span>
                <span class="n">base_estimator</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">))</span>

        <span class="c1"># check if regressor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_regressor</span><span class="p">(</span><span class="n">base_estimator</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base_estimator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> has to be a regressor.&quot;</span> <span class="o">%</span> <span class="n">base_estimator</span><span class="p">)</span>

        <span class="c1"># treat per second acqusition function specially</span>
        <span class="n">is_multi_regressor</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_estimator</span><span class="p">,</span> <span class="n">MultiOutputRegressor</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;ps&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_multi_regressor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span> <span class="o">=</span> <span class="n">MultiOutputRegressor</span><span class="p">(</span><span class="n">base_estimator</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span> <span class="o">=</span> <span class="n">base_estimator</span>

        <span class="c1"># Configure optimizer</span>

        <span class="c1"># decide optimizer based on gradient information</span>
        <span class="k">if</span> <span class="n">acq_optimizer</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_gradients</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="p">):</span>
                <span class="n">acq_optimizer</span> <span class="o">=</span> <span class="s2">&quot;lbfgs&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">acq_optimizer</span> <span class="o">=</span> <span class="s2">&quot;sampling&quot;</span>

        <span class="k">if</span> <span class="n">acq_optimizer</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;lbfgs&quot;</span><span class="p">,</span> <span class="s2">&quot;sampling&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected acq_optimizer to be &#39;lbfgs&#39; or &quot;</span>
                             <span class="s2">&quot;&#39;sampling&#39;, got </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">acq_optimizer</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">has_gradients</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">acq_optimizer</span> <span class="o">!=</span> <span class="s2">&quot;sampling&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The regressor </span><span class="si">{0}</span><span class="s2"> should run with &quot;</span>
                             <span class="s2">&quot;acq_optimizer&quot;</span>
                             <span class="s2">&quot;=&#39;sampling&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">base_estimator</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acq_optimizer</span> <span class="o">=</span> <span class="n">acq_optimizer</span>

        <span class="c1"># record other arguments</span>
        <span class="k">if</span> <span class="n">acq_optimizer_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">acq_optimizer_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_points</span> <span class="o">=</span> <span class="n">acq_optimizer_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n_points&quot;</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_restarts_optimizer</span> <span class="o">=</span> <span class="n">acq_optimizer_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;n_restarts_optimizer&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">acq_optimizer_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n_jobs&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acq_optimizer_kwargs</span> <span class="o">=</span> <span class="n">acq_optimizer_kwargs</span>

        <span class="c1"># Configure search space</span>

        <span class="c1"># normalize space if GP regressor</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="p">,</span> <span class="n">GaussianProcessRegressor</span><span class="p">):</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="n">normalize_dimensions</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">space</span> <span class="o">=</span> <span class="n">Space</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>

        <span class="c1"># record categorical and non-categorical indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cat_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_non_cat_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">Categorical</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cat_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_non_cat_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>

        <span class="c1"># Initialize storage for optimization</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_queue_size</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;model_queue_size should be an int or None, &quot;</span>
                            <span class="s2">&quot;got </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">model_queue_size</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_model_queue_size</span> <span class="o">=</span> <span class="n">model_queue_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xi</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yi</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Initialize cache for `ask` method responses</span>

        <span class="c1"># This ensures that multiple calls to `ask` with n_points set</span>
        <span class="c1"># return same sets of points. Reset to {} at every call to `tell`.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_</span> <span class="o">=</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="Optimizer.copy"><a class="viewcode-back" href="../../../modules/generated/skopt.optimizer.Optimizer.html#skopt.Optimizer.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a shallow copy of an instance of the optimizer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_state : int, RandomState instance, or None (default)</span>
<span class="sd">            Set the random state of the copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">Optimizer</span><span class="p">(</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span>
            <span class="n">base_estimator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="p">,</span>
            <span class="n">n_initial_points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_initial_points_</span><span class="p">,</span>
            <span class="n">acq_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span><span class="p">,</span>
            <span class="n">acq_optimizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">acq_optimizer</span><span class="p">,</span>
            <span class="n">acq_func_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">acq_func_kwargs</span><span class="p">,</span>
            <span class="n">acq_optimizer_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">acq_optimizer_kwargs</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;gains_&quot;</span><span class="p">):</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">gains_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gains_</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="p">:</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">_tell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">optimizer</span></div>

<div class="viewcode-block" id="Optimizer.ask"><a class="viewcode-back" href="../../../modules/generated/skopt.optimizer.Optimizer.html#skopt.Optimizer.ask">[docs]</a>    <span class="k">def</span> <span class="nf">ask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;cl_min&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Query point or multiple points at which objective should be evaluated.</span>

<span class="sd">        n_points : int or None, default=None</span>
<span class="sd">            Number of points returned by the ask method.</span>
<span class="sd">            If the value is None, a single point to evaluate is returned.</span>
<span class="sd">            Otherwise a list of points to evaluate is returned of size</span>
<span class="sd">            n_points. This is useful if you can evaluate your objective in</span>
<span class="sd">            parallel, and thus obtain more objective function evaluations per</span>
<span class="sd">            unit of time.</span>

<span class="sd">        strategy : string, default=&quot;cl_min&quot;</span>
<span class="sd">            Method to use to sample multiple points (see also `n_points`</span>
<span class="sd">            description). This parameter is ignored if n_points = None.</span>
<span class="sd">            Supported options are `&quot;cl_min&quot;`, `&quot;cl_mean&quot;` or `&quot;cl_max&quot;`.</span>

<span class="sd">            - If set to `&quot;cl_min&quot;`, then constant liar strategy is used</span>
<span class="sd">               with lie objective value being minimum of observed objective</span>
<span class="sd">               values. `&quot;cl_mean&quot;` and `&quot;cl_max&quot;` means mean and max of values</span>
<span class="sd">               respectively. For details on this strategy see:</span>

<span class="sd">               https://hal.archives-ouvertes.fr/hal-00732512/document</span>

<span class="sd">               With this strategy a copy of optimizer is created, which is</span>
<span class="sd">               then asked for a point, and the point is told to the copy of</span>
<span class="sd">               optimizer with some fake objective (lie), the next point is</span>
<span class="sd">               asked from copy, it is also told to the copy with fake</span>
<span class="sd">               objective and so on. The type of lie defines different</span>
<span class="sd">               flavours of `cl_x` strategies.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ask</span><span class="p">()</span>

        <span class="n">supported_strategies</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;cl_min&quot;</span><span class="p">,</span> <span class="s2">&quot;cl_mean&quot;</span><span class="p">,</span> <span class="s2">&quot;cl_max&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n_points</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;n_points should be int &gt; 0, got &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">strategy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_strategies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Expected parallel_strategy to be one of &quot;</span> <span class="o">+</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">supported_strategies</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="s2">&quot;got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">strategy</span>
            <span class="p">)</span>

        <span class="c1"># Caching the result with n_points not None. If some new parameters</span>
        <span class="c1"># are provided to the ask, the cache_ is not used.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">strategy</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_</span><span class="p">[(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">strategy</span><span class="p">)]</span>

        <span class="c1"># Copy of the optimizer is made in order to manage the</span>
        <span class="c1"># deletion of points with &quot;lie&quot; objective (the copy of</span>
        <span class="c1"># oiptimizer is simply discarded)</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                                                      <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">))</span>

        <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">ask</span><span class="p">()</span>
            <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">ti_available</span> <span class="o">=</span> <span class="s2">&quot;ps&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">ti</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">opt</span><span class="o">.</span><span class="n">yi</span><span class="p">]</span> <span class="k">if</span> <span class="n">ti_available</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;cl_min&quot;</span><span class="p">:</span>
                <span class="n">y_lie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span> <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">yi</span> <span class="k">else</span> <span class="mf">0.0</span>  <span class="c1"># CL-min lie</span>
                <span class="n">t_lie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> <span class="k">if</span> <span class="n">ti</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">log</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;cl_mean&quot;</span><span class="p">:</span>
                <span class="n">y_lie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span> <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">yi</span> <span class="k">else</span> <span class="mf">0.0</span>  <span class="c1"># CL-mean lie</span>
                <span class="n">t_lie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> <span class="k">if</span> <span class="n">ti</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">log</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">y_lie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span> <span class="k">if</span> <span class="n">opt</span><span class="o">.</span><span class="n">yi</span> <span class="k">else</span> <span class="mf">0.0</span>  <span class="c1"># CL-max lie</span>
                <span class="n">t_lie</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> <span class="k">if</span> <span class="n">ti</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">log</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>

            <span class="c1"># Lie to the optimizer.</span>
            <span class="k">if</span> <span class="s2">&quot;ps&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span><span class="p">:</span>
                <span class="c1"># Use `_tell()` instead of `tell()` to prevent repeated</span>
                <span class="c1"># log transformations of the computation times.</span>
                <span class="n">opt</span><span class="o">.</span><span class="n">_tell</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">y_lie</span><span class="p">,</span> <span class="n">t_lie</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">opt</span><span class="o">.</span><span class="n">_tell</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_lie</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cache_</span> <span class="o">=</span> <span class="p">{(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">strategy</span><span class="p">):</span> <span class="n">X</span><span class="p">}</span>  <span class="c1"># cache_ the result</span>

        <span class="k">return</span> <span class="n">X</span></div>

    <span class="k">def</span> <span class="nf">_ask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Suggest next point at which to evaluate the objective.</span>

<span class="sd">        Return a random point while not at least `n_initial_points`</span>
<span class="sd">        observations have been `tell`ed, after that `base_estimator` is used</span>
<span class="sd">        to determine the next point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_initial_points</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># this will not make a copy of `self.rng` and hence keep advancing</span>
            <span class="c1"># our random state.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Random evaluations exhausted and no &quot;</span>
                                   <span class="s2">&quot;model has been fit.&quot;</span><span class="p">)</span>

            <span class="n">next_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_x</span>
            <span class="n">min_delta_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">next_x</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">min_delta_x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-8</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The objective has been evaluated &quot;</span>
                              <span class="s2">&quot;at this point before.&quot;</span><span class="p">)</span>

            <span class="c1"># return point computed from last call to tell()</span>
            <span class="k">return</span> <span class="n">next_x</span>

<div class="viewcode-block" id="Optimizer.tell"><a class="viewcode-back" href="../../../modules/generated/skopt.optimizer.Optimizer.html#skopt.Optimizer.tell">[docs]</a>    <span class="k">def</span> <span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Record an observation (or several) of the objective function.</span>

<span class="sd">        Provide values of the objective function at points suggested by `ask()`</span>
<span class="sd">        or other points. By default a new model will be fit to all</span>
<span class="sd">        observations. The new model is used to suggest the next point at</span>
<span class="sd">        which to evaluate the objective. This point can be retrieved by calling</span>
<span class="sd">        `ask()`.</span>

<span class="sd">        To add observations without fitting a new model set `fit` to False.</span>

<span class="sd">        To add multiple observations in a batch pass a list-of-lists for `x`</span>
<span class="sd">        and a list of scalars for `y`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : list or list-of-lists</span>
<span class="sd">            Point at which objective was evaluated.</span>

<span class="sd">        y : scalar or list</span>
<span class="sd">            Value of objective at `x`.</span>

<span class="sd">        fit : bool, default=True</span>
<span class="sd">            Fit a model to observed evaluations of the objective. A model will</span>
<span class="sd">            only be fitted after `n_initial_points` points have been told to</span>
<span class="sd">            the optimizer irrespective of the value of `fit`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_x_in_space</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_y_is_valid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># take the logarithm of the computation times</span>
        <span class="k">if</span> <span class="s2">&quot;ps&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_2Dlistlike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="p">[[</span><span class="n">val</span><span class="p">,</span> <span class="n">log</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span> <span class="k">for</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">is_listlike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tell</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_tell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform the actual work of incorporating one or more new points.</span>
<span class="sd">        See `tell()` for the full description.</span>

<span class="sd">        This method exists to give access to the internals of adding points</span>
<span class="sd">        by side stepping all input validation and transformation.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;ps&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_2Dlistlike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n_initial_points</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">is_listlike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n_initial_points</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="c1"># if y isn&#39;t a scalar it means we have been handed a batch of points</span>
        <span class="k">elif</span> <span class="n">is_listlike</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_2Dlistlike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_initial_points</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_listlike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_initial_points</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Type of arguments `x` (</span><span class="si">%s</span><span class="s2">) and `y` (</span><span class="si">%s</span><span class="s2">) &quot;</span>
                             <span class="s2">&quot;not compatible.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

        <span class="c1"># optimizer learned something new - discard cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># after being &quot;told&quot; n_initial_points we switch from sampling</span>
        <span class="c1"># random points to using a surrogate model</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fit</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_initial_points</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span>
           <span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">transformed_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">transformed_bounds</span><span class="p">)</span>
            <span class="n">est</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_estimator_</span><span class="p">)</span>

            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="n">est</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;next_xs_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span> <span class="o">==</span> <span class="s2">&quot;gp_hedge&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gains_</span> <span class="o">-=</span> <span class="n">est</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">next_xs_</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_queue_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">est</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_model_queue_size</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">est</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Maximum list size obtained, remove oldest model.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">est</span><span class="p">)</span>

            <span class="c1"># even with BFGS as optimizer we want to sample a large number</span>
            <span class="c1"># of points and then pick the best ones as starting points</span>
            <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                <span class="n">n_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">next_xs_</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cand_acq_func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cand_acq_funcs_</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">_gaussian_acquisition</span><span class="p">(</span>
                    <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">est</span><span class="p">,</span> <span class="n">y_opt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="p">),</span>
                    <span class="n">acq_func</span><span class="o">=</span><span class="n">cand_acq_func</span><span class="p">,</span>
                    <span class="n">acq_func_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">acq_func_kwargs</span><span class="p">)</span>
                <span class="c1"># Find the minimum of the acquisition function by randomly</span>
                <span class="c1"># sampling points from the space</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_optimizer</span> <span class="o">==</span> <span class="s2">&quot;sampling&quot;</span><span class="p">:</span>
                    <span class="n">next_x</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">values</span><span class="p">)]</span>

                <span class="c1"># Use BFGS to find the mimimum of the acquisition function, the</span>
                <span class="c1"># minimization starts from `n_restarts_optimizer` different</span>
                <span class="c1"># points and the best minimum is used</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_optimizer</span> <span class="o">==</span> <span class="s2">&quot;lbfgs&quot;</span><span class="p">:</span>
                    <span class="n">x0</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">values</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_restarts_optimizer</span><span class="p">]]</span>

                    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                        <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)(</span>
                            <span class="n">delayed</span><span class="p">(</span><span class="n">fmin_l_bfgs_b</span><span class="p">)(</span>
                                <span class="n">gaussian_acquisition_1D</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>
                                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">est</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="p">),</span> <span class="n">cand_acq_func</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">acq_func_kwargs</span><span class="p">),</span>
                                <span class="n">bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">transformed_bounds</span><span class="p">,</span>
                                <span class="n">approx_grad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">maxiter</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x0</span><span class="p">)</span>

                    <span class="n">cand_xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">])</span>
                    <span class="n">cand_acqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">])</span>
                    <span class="n">next_x</span> <span class="o">=</span> <span class="n">cand_xs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">cand_acqs</span><span class="p">)]</span>

                <span class="c1"># lbfgs should handle this but just in case there are</span>
                <span class="c1"># precision errors.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_categorical</span><span class="p">:</span>
                    <span class="n">next_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
                        <span class="n">next_x</span><span class="p">,</span> <span class="n">transformed_bounds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="n">transformed_bounds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">next_xs_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_x</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span> <span class="o">==</span> <span class="s2">&quot;gp_hedge&quot;</span><span class="p">:</span>
                <span class="n">logits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gains_</span><span class="p">)</span>
                <span class="n">logits</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
                <span class="n">exp_logits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">*</span> <span class="n">logits</span><span class="p">)</span>
                <span class="n">probs</span> <span class="o">=</span> <span class="n">exp_logits</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">exp_logits</span><span class="p">)</span>
                <span class="n">next_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_xs_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
                                                                      <span class="n">probs</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">next_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_xs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># note the need for [0] at the end</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span>
                <span class="n">next_x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Pack results</span>
        <span class="k">return</span> <span class="n">create_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span>
                             <span class="n">models</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_y_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the shape and types of x and y are consistent.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;ps&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">acq_func</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_2Dlistlike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">y</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected y to be a list of (func_val, t)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">is_listlike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected y to be (func_val, t)&quot;</span><span class="p">)</span>

        <span class="c1"># if y isn&#39;t a scalar it means we have been handed a batch of points</span>
        <span class="k">elif</span> <span class="n">is_listlike</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_2Dlistlike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y_value</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_value</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;expected y to be a list of scalars&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">is_listlike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`func` should return a scalar&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Type of arguments `x` (</span><span class="si">%s</span><span class="s2">) and `y` (</span><span class="si">%s</span><span class="s2">) &quot;</span>
                             <span class="s2">&quot;not compatible.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

<div class="viewcode-block" id="Optimizer.run"><a class="viewcode-back" href="../../../modules/generated/skopt.optimizer.Optimizer.html#skopt.Optimizer.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute ask() + tell() `n_iter` times&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ask</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">create_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span>
                             <span class="n">models</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">)</span></div>

<div class="viewcode-block" id="Optimizer.update_next"><a class="viewcode-back" href="../../../modules/generated/skopt.optimizer.Optimizer.html#skopt.Optimizer.update_next">[docs]</a>    <span class="k">def</span> <span class="nf">update_next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the value returned by opt.ask(). Useful if a parameter</span>
<span class="sd">        was updated after ask was called.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Ask for a new next_x.</span>
        <span class="c1"># We only need to overwrite _next_x if it exists.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_next_x&#39;</span><span class="p">):</span>
            <span class="n">opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_next_x</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">_next_x</span></div>

<div class="viewcode-block" id="Optimizer.get_result"><a class="viewcode-back" href="../../../modules/generated/skopt.optimizer.Optimizer.html#skopt.Optimizer.get_result">[docs]</a>    <span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the same result that would be returned by opt.tell()</span>
<span class="sd">        but without calling tell</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        res : `OptimizeResult`, scipy object</span>
<span class="sd">            OptimizeResult instance with the required information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">create_result</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="p">,</span>
                             <span class="n">models</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">)</span></div></div>
</pre></div>

      </div>
    <div class="container">
      <footer class="sk-content-footer">
            &copy; 2017 - 2020, The scikit-optimize contributors..
      </footer>
    </div>
  </div>
</div>
<script src="../../../_static/js/vendor/bootstrap.min.js"></script>


<script>
$(document).ready(function() {
    /* Add a [>>>] button on the top-right corner of code samples to hide
     * the >>> and ... prompts and the output and thus make the code
     * copyable. */
    var div = $('.highlight-python .highlight,' +
                '.highlight-python3 .highlight,' +
                '.highlight-pycon .highlight,' +
		'.highlight-default .highlight')
    var pre = div.find('pre');

    // get the styles from the current theme
    pre.parent().parent().css('position', 'relative');
    var hide_text = 'Hide prompts and outputs';
    var show_text = 'Show prompts and outputs';

    // create and add the button to all the code blocks that contain >>>
    div.each(function(index) {
        var jthis = $(this);
        if (jthis.find('.gp').length > 0) {
            var button = $('<span class="copybutton">&gt;&gt;&gt;</span>');
            button.attr('title', hide_text);
            button.data('hidden', 'false');
            jthis.prepend(button);
        }
        // tracebacks (.gt) contain bare text elements that need to be
        // wrapped in a span to work with .nextUntil() (see later)
        jthis.find('pre:has(.gt)').contents().filter(function() {
            return ((this.nodeType == 3) && (this.data.trim().length > 0));
        }).wrap('<span>');
    });

    // define the behavior of the button when it's clicked
    $('.copybutton').click(function(e){
        e.preventDefault();
        var button = $(this);
        if (button.data('hidden') === 'false') {
            // hide the code output
            button.parent().find('.go, .gp, .gt').hide();
            button.next('pre').find('.gt').nextUntil('.gp, .go').css('visibility', 'hidden');
            button.css('text-decoration', 'line-through');
            button.attr('title', show_text);
            button.data('hidden', 'true');
        } else {
            // show the code output
            button.parent().find('.go, .gp, .gt').show();
            button.next('pre').find('.gt').nextUntil('.gp, .go').css('visibility', 'visible');
            button.css('text-decoration', 'none');
            button.attr('title', hide_text);
            button.data('hidden', 'false');
        }
    });

	/*** Add permalink buttons next to glossary terms ***/
	$('dl.glossary > dt[id]').append(function() {
		return ('<a class="headerlink" href="#' +
			    this.getAttribute('id') +
			    '" title="Permalink to this term"></a>');
	});
  /*** Hide navbar when scrolling down ***/
  // Returns true when headerlink target matches hash in url
  (function() {
    hashTargetOnTop = function() {
        var hash = window.location.hash;
        if ( hash.length < 2 ) { return false; }

        var target = document.getElementById( hash.slice(1) );
        if ( target === null ) { return false; }

        var top = target.getBoundingClientRect().top;
        return (top < 2) && (top > -2);
    };

    // Hide navbar on load if hash target is on top
    var navBar = document.getElementById("navbar");
    var navBarToggler = document.getElementById("sk-navbar-toggler");
    var navBarHeightHidden = "-" + navBar.getBoundingClientRect().height + "px";
    var $window = $(window);

    hideNavBar = function() {
        navBar.style.top = navBarHeightHidden;
    };

    showNavBar = function() {
        navBar.style.top = "0";
    }

    if (hashTargetOnTop()) {
        hideNavBar()
    }

    var prevScrollpos = window.pageYOffset;
    hideOnScroll = function(lastScrollTop) {
        if (($window.width() < 768) && (navBarToggler.getAttribute("aria-expanded") === 'true')) {
            return;
        }
        if (lastScrollTop > 2 && (prevScrollpos <= lastScrollTop) || hashTargetOnTop()){
            hideNavBar()
        } else {
            showNavBar()
        }
        prevScrollpos = lastScrollTop;
    };

    /*** high performance scroll event listener***/
    var raf = window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        window.oRequestAnimationFrame;
    var lastScrollTop = $window.scrollTop();

    if (raf) {
        loop();
    }

    function loop() {
        var scrollTop = $window.scrollTop();
        if (lastScrollTop === scrollTop) {
            raf(loop);
            return;
        } else {
            lastScrollTop = scrollTop;
            hideOnScroll(lastScrollTop);
            raf(loop);
        }
    }
  })();
});

</script>
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <script src="https://scikit-optimize.github.io/versionwarning.js"></script>
</body>
</html>