.. note::
    :class: sphx-glr-download-link-note

    Click :ref:`here <sphx_glr_download_auto_examples_exploration-vs-exploitation.py>` to download the full example code or to run this example in your browser via Binder
.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_exploration-vs-exploitation.py:


===========================
Exploration vs exploitation
===========================

Sigurd Carlen, September 2019.
Reformatted by Holger Nahrstaedt 2020

.. currentmodule:: skopt


We can control how much the acqusition function favors exploration and
exploitation by tweaking the two parameters kappa and xi. Higher values
means more exploration and less exploitation and vice versa with low values.

kappa is only used if acq_func is set to "LCB". xi is used when acq_func is
"EI" or "PI". By default the acqusition function is set to "gp_hedge" which
chooses the best of these three. Therefore I recommend not using gp_hedge
when tweaking exploration/exploitation, but instead choosing "LCB",
"EI" or "PI.

The way to pass kappa and xi to the optimizer is to use the named argument
"acq_func_kwargs". This is a dict of extra arguments for the aqcuisittion
function.

If you want opt.ask() to give a new acquisition value imdediatly after
tweaking kappa or xi call opt.update_next(). This ensures that the next
value is updated with the new acquisition parameters.


.. code-block:: default

    print(__doc__)

    import numpy as np
    np.random.seed(1234)
    import matplotlib.pyplot as plt









Toy example
-----------
First we define our objective like in the ask-and-tell example notebook and
define a plotting function. We do however only use on initial random point.
All points afterthe first one is therefore choosen by the acquisition
function.


.. code-block:: default


    from skopt.learning import ExtraTreesRegressor
    from skopt import Optimizer

    noise_level = 0.1

    # Our 1D toy problem, this is the function we are trying to
    # minimize
    def objective(x, noise_level=noise_level):
        return np.sin(5 * x[0]) * (1 - np.tanh(x[0] ** 2)) +\
               np.random.randn() * noise_level









.. code-block:: default


    opt = Optimizer([(-2.0, 2.0)], "GP", n_initial_points = 1,
                    acq_optimizer="sampling")









.. code-block:: default


    x = np.linspace(-2, 2, 400).reshape(-1, 1)
    fx = np.array([objective(x_i, noise_level=0.0) for x_i in x])









.. code-block:: default


    from skopt.acquisition import gaussian_ei
    def plot_optimizer(opt, x, fx):
        model = opt.models[-1]
        x_model = opt.space.transform(x.tolist())

        # Plot true function.
        plt.plot(x, fx, "r--", label="True (unknown)")
        plt.fill(np.concatenate([x, x[::-1]]),
                 np.concatenate([fx - 1.9600 * noise_level,
                                 fx[::-1] + 1.9600 * noise_level]),
                 alpha=.2, fc="r", ec="None")

        # Plot Model(x) + contours
        y_pred, sigma = model.predict(x_model, return_std=True)
        plt.plot(x, y_pred, "g--", label=r"$\mu(x)$")
        plt.fill(np.concatenate([x, x[::-1]]),
                 np.concatenate([y_pred - 1.9600 * sigma,
                                 (y_pred + 1.9600 * sigma)[::-1]]),
                 alpha=.2, fc="g", ec="None")

        # Plot sampled points
        plt.plot(opt.Xi, opt.yi,
                 "r.", markersize=8, label="Observations")

        acq = gaussian_ei(x_model, model, y_opt=np.min(opt.yi))
        # shift down to make a better plot
        acq = 4 * acq - 2
        plt.plot(x, acq, "b", label="EI(x)")
        plt.fill_between(x.ravel(), -2.0, acq.ravel(), alpha=0.3, color='blue')

        # Adjust plot layout
        plt.grid()
        plt.legend(loc='best')








We run a an optimization loop with standard settings


.. code-block:: default


    for i in range(30):
        next_x = opt.ask()
        f_val = objective(next_x)
        opt.tell(next_x, f_val)
    # The same output could be created with opt.run(objective, n_iter=30)
    plot_optimizer(opt, x, fx)




.. image:: /auto_examples/images/sphx_glr_exploration-vs-exploitation_001.png
    :class: sphx-glr-single-img





We see that some minima is found and "exploited"

Now lets try to set kappa and xi using'to other values and
pass it to the optimizer:


.. code-block:: default

    acq_func_kwargs = {"xi": 10000, "kappa": 10000}








.. code-block:: default


    opt = Optimizer([(-2.0, 2.0)], "GP", n_initial_points=1,
                    acq_optimizer="sampling",
                    acq_func_kwargs=acq_func_kwargs)








.. code-block:: default

    opt.run(objective, n_iter=20)
    plot_optimizer(opt, x, fx)



.. image:: /auto_examples/images/sphx_glr_exploration-vs-exploitation_002.png
    :class: sphx-glr-single-img





We see that the points are more random now.

This works both for kappa when using acq_func="LCB":


.. code-block:: default

    opt = Optimizer([(-2.0, 2.0)], "GP", n_initial_points=1,
                    acq_func="LCB", acq_optimizer="sampling",
                    acq_func_kwargs=acq_func_kwargs)








.. code-block:: default

    opt.run(objective, n_iter=20)
    plot_optimizer(opt, x, fx)



.. image:: /auto_examples/images/sphx_glr_exploration-vs-exploitation_003.png
    :class: sphx-glr-single-img





And for xi when using acq_func="EI": or acq_func="PI":


.. code-block:: default


    opt = Optimizer([(-2.0, 2.0)], "GP", n_initial_points=1,
                    acq_func="PI", acq_optimizer="sampling",
                    acq_func_kwargs=acq_func_kwargs)








.. code-block:: default

    opt.run(objective, n_iter=20)
    plot_optimizer(opt, x, fx)



.. image:: /auto_examples/images/sphx_glr_exploration-vs-exploitation_004.png
    :class: sphx-glr-single-img





We can also favor exploitaton:


.. code-block:: default

    acq_func_kwargs = {"xi": 0.000001, "kappa": 0.001}









.. code-block:: default

    opt = Optimizer([(-2.0, 2.0)], "GP", n_initial_points=1,
                    acq_func="LCB", acq_optimizer="sampling",
                    acq_func_kwargs=acq_func_kwargs)








.. code-block:: default

    opt.run(objective, n_iter=20)
    plot_optimizer(opt, x, fx)



.. image:: /auto_examples/images/sphx_glr_exploration-vs-exploitation_005.png
    :class: sphx-glr-single-img






.. code-block:: default

    opt = Optimizer([(-2.0, 2.0)], "GP", n_initial_points=1,
                    acq_func="EI", acq_optimizer="sampling",
                    acq_func_kwargs=acq_func_kwargs)








.. code-block:: default

    opt.run(objective, n_iter=20)
    plot_optimizer(opt, x, fx)



.. image:: /auto_examples/images/sphx_glr_exploration-vs-exploitation_006.png
    :class: sphx-glr-single-img






.. code-block:: default

    opt = Optimizer([(-2.0, 2.0)], "GP", n_initial_points=1,
                    acq_func="PI", acq_optimizer="sampling",
                    acq_func_kwargs=acq_func_kwargs)








.. code-block:: default

    opt.run(objective, n_iter=20)
    plot_optimizer(opt, x, fx)




.. image:: /auto_examples/images/sphx_glr_exploration-vs-exploitation_007.png
    :class: sphx-glr-single-img





Note that negative values does not work with the "PI"-acquisition function
but works with "EI":


.. code-block:: default

    acq_func_kwargs = {"xi": -1000000000000}








.. code-block:: default


    opt = Optimizer([(-2.0, 2.0)], "GP", n_initial_points=1,
                    acq_func="PI", acq_optimizer="sampling",
                    acq_func_kwargs=acq_func_kwargs)








.. code-block:: default

    opt.run(objective, n_iter=20)
    plot_optimizer(opt, x, fx)



.. image:: /auto_examples/images/sphx_glr_exploration-vs-exploitation_008.png
    :class: sphx-glr-single-img






.. code-block:: default

    opt = Optimizer([(-2.0, 2.0)], "GP", n_initial_points=1,
                    acq_func="EI", acq_optimizer="sampling",
                    acq_func_kwargs=acq_func_kwargs)








.. code-block:: default

    opt.run(objective, n_iter=20)
    plot_optimizer(opt, x, fx)



.. image:: /auto_examples/images/sphx_glr_exploration-vs-exploitation_009.png
    :class: sphx-glr-single-img





Changing kappa and xi on the go
-------------------------------
If we want to change kappa or ki at any point during our optimization
process we just replace opt.acq_func_kwargs. Remember to call
`opt.update_next()` after the change, in order for next point to be
recalculated.


.. code-block:: default

    acq_func_kwargs = {"kappa": 0}








.. code-block:: default

    opt = Optimizer([(-2.0, 2.0)], "GP", n_initial_points=1,
                    acq_func="LCB", acq_optimizer="sampling",
                    acq_func_kwargs=acq_func_kwargs)








.. code-block:: default

    opt.acq_func_kwargs




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    {'kappa': 0}




.. code-block:: default

    opt.run(objective, n_iter=20)
    plot_optimizer(opt, x, fx)



.. image:: /auto_examples/images/sphx_glr_exploration-vs-exploitation_010.png
    :class: sphx-glr-single-img






.. code-block:: default

    acq_func_kwargs = {"kappa": 100000}








.. code-block:: default


    opt.acq_func_kwargs = acq_func_kwargs
    opt.update_next()








.. code-block:: default

    opt.run(objective, n_iter=20)
    plot_optimizer(opt, x, fx)



.. image:: /auto_examples/images/sphx_glr_exploration-vs-exploitation_011.png
    :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  30.969 seconds)

**Estimated memory usage:**  8 MB


.. _sphx_glr_download_auto_examples_exploration-vs-exploitation.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example


  .. container:: binder-badge

    .. image:: https://mybinder.org/badge_logo.svg
      :target: https://mybinder.org/v2/gh/scikit-optimize/scikit-optimize/master?urlpath=lab/tree/notebooks/auto_examples/exploration-vs-exploitation.ipynb
      :width: 150 px


  .. container:: sphx-glr-download

     :download:`Download Python source code: exploration-vs-exploitation.py <exploration-vs-exploitation.py>`



  .. container:: sphx-glr-download

     :download:`Download Jupyter notebook: exploration-vs-exploitation.ipynb <exploration-vs-exploitation.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
